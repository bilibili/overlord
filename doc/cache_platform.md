
## etcd 存储设计

### 目录结构

```
overlord
    /specs/$spec
    /appids/
        /$appid/
            /${id} # value is cluster_name
    /clusters
        /cluster1
            /appids/${appids}
            /info
            /instances
                /${instance_id} # value is $ip:$port, auto generated by etcd
        /cluster2
            /instances
                /${instance_id} # value is $ip:$port, auto generated by etcd
    /config
        /cluster1
    /jobs
        /$role # 分组，基于role实现资源和任务的隔离
            /$jobid # id was auto gen by etcd
    /job_detial
        /$jobid
            /state #state of the global job
    /instances/$ip:$port/
        /type (cache type,eg:redis,memcached,redis-cluster)
        /cluster # cluster name
        /taskid # mesos taskid
        /alias # alias of node
        /weight  # instance weight number
        /state # instance state
        /nodes.conf
        /server.conf (服务配置文件 eg:redis.conf memcached.conf)
    /heartbeat
        /$ip:$port #维持服务心跳，通过refresh刷新ttl
    /framework #store framework id,in case of framework fault recover.
    /fileserver # file server is the url for http download binary, e.g. "http://127.0.0.1/fs"
```
#### 目录说明

* /overlord 为项目根目录
* /clusters 为集群目录
* /cluster$i 为具体的集群信息
* /instances 为集群节点目录
* /info 为节点的信息详情，按json格式存储
* /server.conf 为服务启动配置项，value为服务的配置内容
* /nodes.conf 为redis-cluster的nodes信息，用于mock模式启动redis-cluster

* /config 为配置目录
* /cluster$i 为集群的具体配置

* /jobs 为前端任务目录
* /$jobid 为任务id，value是任务详情 
* /instances 为单独设计的 instance 路径，辅助 ip/port 为后缀路径辅助定位
			
## sheduler 设计

#### scheduler 主体流程

1. 连接到etcd/zk 获取 `/overlord/job` 目录下未完成的 job 并监听目录实时获取 api-server 下发的任务信息并保存到本地任务队列
2. 注册到 mesos master 并订阅 mesos event。
3. 监听 event_offer 事件，并判断当前任务队列是否有未完成任务
4. oferr resources 是否符合task任务资源描述需求 （判断依据 mem cpu balance）
5. 接受 offer，并下发 executor 任务给 agent
6. 监听 agent 回复的 event_update 事件
7. event 为 running 时，则表示任务启动成功并且正常运行
8. event 为 failed 时，scheduler 需要重新调度重新分配task
9. 当 running 数为 task 需要部署的 instance 数时，表示所有任务部署成功，scheduler 更新 task 状态为完成并写入将状态写入 ectd

#### TaskInfo 约定
taskInfo.Data 存储 ip:port ,executor根据ip:port 定位到etcd获取对应的配置以及生成相关启动命令
## Executor 约定

### 注意

无论是服务，还是缓存配置还是目录，始终用 `memcache` 指代 memcache 服务。仅在表示 memcached 这个 binary 本身的时候使用 memcached

### 目录约定
一些约定：

1. redis server binary 的存放路径为 `/data/lib/redis/4.0.8/bin/redis-server`
2. memcache 的存放路径为 `/data/lib/memcache/1.5.10/bin/memcached`
3. 多版本共存请修改 4.0.8(1.5.10) 到对应版本
4. redis 的 working dir 位置 `/data/${port}`
5. redis 节点的配置文件约定为 `/data/${port}/redis.conf`
6. redis_cluster 节点的 `nodes.conf` 文件约定为 `/data/${port}/nodes.conf`
7. redis 的 pid 文件为 `redis.pid` 放在 working dir 目录下。
8. memcache 类似。
9. 所有缓存服务都需要在 working dir 下维持一个 meta.toml 文件，用来存储类似 "cluster name"等节点信息。严格禁止并发修改这个文件。
10. mesos 的 executor 的 tmp dir 目录为 /data/var/overlord/tmp/{task_id}/

所有文件（目录）的权限均为 `0755`，用户恒为 `root.root`


一个典型的 redis 目录为：

```
7010
├── console.log # 启动日志
├── meta.tmol   # 元信息，里面保存了启动关闭命令
├── nodes.conf  # 仅存在于 redis cluster 的 nodes.conf 文件
├── redis.conf  # redis 配置文件
└── redis.pid   # redis 的 pid 
```

## mesos 部署说明
### mesos agent部署配置
1.需要保证resources端口范围服务redis cluster端口要求。eg(--resources='ports:[21000-24000,31000-34000]')redis cluster默认监听 端口为port以及port+10000
2.设置 --hostname_lookup=false ,使用ip作为agent hostname。缓存节点通过hostname ip加上分配的端口号进行访问
